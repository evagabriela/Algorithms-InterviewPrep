Algorithm's Introduction:

The first step towards an understanding of why the study and knowledge of algorithms are so important is to define exactly what we mean by an algorithm. According to the popular algorithms textbook Introduction to Algorithms (Second Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein), "an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values as output." In other words, algorithms are like road maps for accomplishing a given, well-defined task. So, a chunk of code that calculates the terms of the Fibonacci sequence is an implementation of a particular algorithm. Even a simple function for adding two numbers is an algorithm in a sense, but just a simple one. 

Some algorithms, like those that compute the Fibonacci sequences, are intuitive and may be innately embedded into our logical thinking and problem solving skills. However, for most of us, complex algorithms are best studied so we can use them as building blocks for more efficient logical problem solving in the future. In fact, you may be surprised to learn just how many complex algorithms people use every day when they check their e-mail or listen to music on their computers. This article will introduce some basic ideas related to the analysis of algorithms, and then put these into practice with a few examples illustrating why it is important to know about algorithms. 

There are many ways to represent an algorithm and the programming language code itself is one of them. However, quite often it is much better or easier not to solve entire problem at once but just an outline and then fill the blanks as you go.

* My personal favorite here is pseudo code, and only to cover a general abstract outline of the algorithm in question - it's ridiculous to get into details with pseudocode, that's what real code is for.

* But real code can be used for the outline. For example, TDD people like to design the algorithm as they code, and since they can't solve it all at once either, they design an outline of the program execution in real code, and use mock objects (or functions, methods...) as blanks to be filled in later.

* UML Activity diagrams seem to be a modern incarnation of old-style flowcharts with added notation for the new stuff like polymorphism and multithreading. I can't really say how useful this is, since I didn't really use them much - I'm just mentioning it for completeness.

* Also, if you are basing your algorithm on switching between states, then a state diagram is quite helpful.

* Generally, any mean you have to simply sketch the idea behind a certain algorithm is a good way to go.